
------

API 0 - affero license compliance

* GET /api/affero/hash
** "f572d396fae9206628714fb2ce00f72e94f2258f" (the git source-control identifier of the commit that is running)
** baked into the war file at compile time

* GET /api/affero/source
** (valid redirect or direct-asset-fetch) ... maybe cached, but derived from locally-accessible git repo?
** "exception:${license_number}" - where ${license_number} is provided by (and purchased from) Allogy
** "non-compliant" & http-status=500 - admission that this instance is not setup to comply with the affero license

------

API 1 - qrauthd to web (i.e. generally-available sqrl login for shell access)

?: 1st... map username -> [ sqrl delegate servers ]

* GET /api/shell/nut/$HOSTNAME/json
** HOSTNAME -> where they are trying to get shell access to
** Generates a SQRL, RSA, or SHELL/CRAM consumable NUT *WITHOUT-DELAY*
** { blob:"OPAQUEBASE64ISHTOKEN", qr_url:"sqrl://*****", link_url:"sqrl://*****", poll_url:"https://*****" }

* POST /api/shell/session/$HOSTNAME
** RESPONSE -> "${NUT.blob}:${API_HASH}:${DIGEST}" where DIGEST=sha1(NUT.blob+SHELL_KEY), & API_HASH is pre-hashed tenant api key
** *Consumes* NUT (success or failure)
** Activates and returns a shell-level authentication ticket (for this tenant) on success
** { ticket:"OPAQUE-ASCII-TOKEN", expires:102394123094 }

* POST /api/shell/poll/$HOSTNAME/$NUT/json
** HOSTNAME -> where they are trying to get shell access to
** TICKET   -> a shell-level authentication ticket (from the above shell/session command)
** NB: NUT is *consumed* if polling succeeds (that is, if return is success and other than empty object)
** { shell:true, username:bob, uid:123, groups: { "wheel":321, "disk":987}} 
** {} <-- empty object means try again
** { shell:false, passed:true } <--- valid sqrl auth, no user account
** { shell:false, passed:true, uid:212 } <--- valid sqrl auth, user account w/o username

Client MUST still verify username
Client MUST emit a warning if uids do not match (but use system-level uid?)
Server MUST beware of too many outstanding sqrl requests or unreachable server (DoS & fail-safe)
MAYBE use more shell-friendly encoding than json (but groups list?)
CONSIDER if we support multiple sqrl servers, then don't we need separate tenant-secrets?
CONSIDER use of tenantperson::id as a uid (risk of overflow? tenant migration?)
CONSIDER pre-shell mitm effects such as SSH interception (can sqrl or protocol help? show host key pattern?)

* POST /api/shell/blessed/${USER}
** HOSTNAME -> where they are trying to get shell access to
** TICKET   -> a shell-level authentication ticket (from the above shell/session command)
** { shell:true, username:bob, uid:123, groups: { "wheel":321, "disk":987}} 
** { shell:false, uid: 1234 } - a valid user, of this tenant, but no shell access
** { shell:false } - never heard of 'em
** NB: this may be consulted before *or* after the user has passed other checks, and is the fallback for lack of git repo updating
** NB: if local data (e.g. from previous connections) indicate the user *does* have shell access, then in the face of a network failure or server error one must assume the user *DOES* have shell access
** NB: the status codes shall also be distinct for true (200) and false (202)
** NB: an invalid username will generate a 400 error response

??: should 'blessed' and 'poll' return list of active rsa pubkeys too?

* POST /api/shell/pubkeys/$HOSTNAME[/$USER]
** HOSTNAME -> where they are trying to get shell access to
** TICKET   -> a shell-level authentication ticket (from the above shell/session command)
** Returns stream of one or all public keys that have shell-level access to this host, can be used as a pull-replication from web.
** e.g."/user/bob/pubkey-123\nssh-rsa 1203498 bob@example.com\n"
** NB: this should never return a pubkey for 'root' (or any system user), if it does... don't trust *any* of the public keys returned.
** NB: the post condition of this call are broad and sweeping (basically re-writing the entire login authorization)
** This means that you must *REALLY-TRUST* the originating server, and the PKI that is security your link to it... THINK FIRST!

------

API 2 - web (or localhost) to qrauthd (i.e. internal synchronization of shell-level user accounts)

SOCKET-level protocol (not HTTP)

(1a) web presents self as authenticating as a particular person, all fields required
> ${HOSTNAME}
< web
< auth.domain.com
< ${HASHED_TENANT_API_KEY}
{{ INSERT SMP NEGOTIATION: where X=SERVER_SSL_FINGERPRINT+SHELL_KEY; web is alice, qrauthd is Bob }}
> OK

(1b) unix socket identity (kernel answers: "who's calling?")
> ${HOSTNAME}
< socket        < service calls getsockopt(..., SO_PEERCRED, ...) to identify the caller, omits per-request identity?
> OK

(1c) local process identifies via local filesystem (deprecated)
> ${HOSTNAME}
< fscram
< ${USER}
> ${CHALLENGE}  > A short blob of ascii text (no whitespace), that the user is to write to a /tmp file
< /tmp/${WHERE} < Where $USER wrote $CHALLENGE, and where you can read it (and verify both the contents and the owner of the file)
> OK            > $USER can now delete the file (qrauthd may not be able to)

...hereafter, the conversation takes the form:
< 149123409877                                          < the effective-time (commit-time) of the following request
< Bob Jones
< bjones@example.com
< method:1:totp:120394123498:120394123498:1024982349328 < (method  #1, type, modified, login, expire)
< ${REQUEST}
> ${RESPONSE}

NB: EVERY request, EVEN READ REQUESTS indicate who is doing the reading!!!!

[in general, both REQUEST and RESPONSE are one-line, as follows]

< exist:privy:/group/name[:key]
> FALSE

NB: when checking /user/* or /group/* (no trailing path), qrauthd must *also* check /etc/passwd and /etc/group (via SSSD)

< set:secret:/user/bob/props:key:value
> OK

< read:privy:/user/bob/otp-h-yubi-1.counter[:key]
> OK

?: should we allow reading from 'secret' repo? or just have web assume that it's db is correct (no updating from shell-side?)

< bye
> BYE   > server closes socket

------------

API 3 - tenant utilities

* POST /api/tenant/create
** PRIMARY={very-unique-ascii-string-or-guid}
** SECONDARY={another-very-unique-ascii-string-or-guid}
** After this call, you may use PRIMARY as your API_KEY... or SECONDARY if PRIMARY is exposed or expired

* POST /api/tenant/rekey
** SECONDARY={your-current-secondary-api-key-which-now-becomes-primary}
** NEXT_KEY={very-unique-ascii-string-or-guid}
** After this call, which proves that you know your secondary key (which should not have been wrapped up in your deployment),
** the secondary key becomes your primary, and the provided NEXT_KEY becomes your SECONDARY... thus, "shifting" them.

(!) all following methods require posting API_KEY (unhashed)

* POST /api/tenant/user/recent
* POST /api/tenant/user/named/$NAMES_CSV
* POST /api/tenant/user/id/$UIDS_CSV
** returns username,uid(tenantperson::id),tenant-fields
** expensive?: tenant-group memberships(name->id),group-derived permissions
** maybe: user's number of banned sites
** maximum number of UIDs?
** performance-oriented; async fetch of tenant (by api key) & listed tenant-person; filters out those whose tenant_id is not the provided one
** returns status of 404 if no match (200 if *any* match)

* POST /api/tenant/user/ban/$UIDS_CSV
* POST /api/tenant/user/unban/$UIDS_CSV
** MESSAGE - required
** Sets (or clears) the deadline and deathmessage, a banned user is effectively preventing the specified users from accessing the tenant's site
** Might (one day?) influence blacklisted ip address logic (if one ip is banned by many distinct tenants?)

* POST /api/tenant/user/banned
** Lists the users that have a deathMessage (or passed deadline)

* POST /api/tenant/user/set/id/$UID (bulk setting fields)
* POST /api/tenant/user/set/id/$UIDS_CSV/$key/$value (set single field; enforces nice keys and values)

* POST /api/tenant/group/named/$NAMES_CSV
* POST /api/tenant/group/id/$UIDS_CSV
** returns groupname,gid(tenantgroup::id),tenant-fields,uids in group
** returns status of 404 if no match (200 if *any* match)

* POST /api/tenant/group/set/id/$GID (bulk setting fields)
* POST /api/tenant/group/set/id/$GID/$key/$value (set single field; enforces nice keys and values)
** NB: setting name & description may transparently fail (or be tenant-specific) if you don't *own* the group name.

* POST /api/tenant/group/list
** lists group names, descriptions, permissions, GIDs, and if you 'own' it (or if then name is 'well-known')

* POST /api/tenant/group/create/$NAME (with name, description, and fields; optional members UID list?)
** returns; GID & if you currently 'own' it

* POST /api/tenant/group/permission/set/$GID/$key
* POST /api/tenant/group/permission/clear/$GID/$key
** sets (or clears) the given permission key for the specified group

* POST /api/tenant/group/member/$GID/$UID
* POST /api/tenant/group/nonmember/$GID/$UID

